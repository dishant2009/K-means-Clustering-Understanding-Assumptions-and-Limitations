<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-means Clustering: When It Works and When It Fails</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
            line-height: 1.6;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-style: italic;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .control-group {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #e0e0e0;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        .control-group span {
            display: inline-block;
            color: #007bff;
            font-weight: bold;
        }
        select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            background-color: white;
        }
        .button-group {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .chart-container {
            position: relative;
            height: 400px;
            background-color: #fafafa;
            border-radius: 5px;
            padding: 10px;
        }
        .full-width {
            grid-column: 1 / -1;
            height: 300px;
        }
        .info-box {
            background-color: #e8f4fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .warning-box {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid #ff9800;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .metric-card {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            border: 1px solid #dee2e6;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .metric-label {
            font-size: 14px;
            color: #6c757d;
            margin-top: 5px;
        }
        .dataset-description {
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
        .algorithm-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .algorithm-box {
            padding: 15px;
            border-radius: 5px;
            background-color: #f9f9f9;
        }
        .kmeans-box {
            border: 2px solid #ff6b6b;
        }
        .dbscan-box {
            border: 2px solid #4ecdc4;
        }
        h3 {
            margin-top: 0;
            color: #333;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>K-means Clustering: Understanding Its Assumptions and Limitations</h1>
        <p class="subtitle">Discover when K-means works perfectly and when it fails spectacularly</p>
        
        <div class="info-box">
            <strong>Key Insight:</strong> K-means assumes clusters are spherical, similar-sized, and equally dense. 
            This visualization shows what happens when these assumptions are violated and compares K-means with DBSCAN, 
            which makes different assumptions about cluster shape and density.
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="dataset-select">Dataset Type:</label>
                <select id="dataset-select" onchange="generateDataset()">
                    <option value="blobs">Well-Separated Blobs (K-means works great!)</option>
                    <option value="moons">Two Moons (Non-spherical clusters)</option>
                    <option value="circles">Concentric Circles (Nested clusters)</option>
                    <option value="aniso">Anisotropic (Different variances)</option>
                    <option value="varied">Varied Sizes (Unequal cluster sizes)</option>
                    <option value="density">Different Densities (Density variation)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="n-clusters">Number of Clusters (K): <span id="n-clusters-value">3</span></label>
                <input type="range" id="n-clusters" min="2" max="6" value="3" step="1" onchange="updateClusterCount()">
            </div>
            
            <div class="control-group">
                <label for="init-method">K-means Initialization:</label>
                <select id="init-method">
                    <option value="kmeans++">K-means++ (Smart)</option>
                    <option value="random">Random (Shows sensitivity)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="dbscan-eps">DBSCAN eps: <span id="dbscan-eps-value">0.3</span></label>
                <input type="range" id="dbscan-eps" min="0.1" max="1.0" value="0.3" step="0.05" onchange="updateEps()">
            </div>
            
            <div class="control-group">
                <label for="dbscan-minpts">DBSCAN minPts: <span id="dbscan-minpts-value">5</span></label>
                <input type="range" id="dbscan-minpts" min="2" max="20" value="5" step="1" onchange="updateMinPts()">
            </div>
            
            <div class="control-group">
                <label for="n-points">Number of Points: <span id="n-points-value">300</span></label>
                <input type="range" id="n-points" min="100" max="1000" value="300" step="50" onchange="updatePointCount()">
            </div>
        </div>

        <div class="button-group">
            <button onclick="runClustering()">Run Clustering</button>
            <button onclick="runMultipleInits()">Show Initialization Sensitivity (10 runs)</button>
            <button onclick="showElbowMethod()">Elbow Method Analysis</button>
        </div>

        <div class="dataset-description" id="dataset-description">
            Select a dataset to see why K-means might struggle with it.
        </div>

        <div class="visualization-grid">
            <div class="chart-container">
                <canvas id="kmeans-chart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="dbscan-chart"></canvas>
            </div>
            <div class="chart-container full-width" id="elbow-container" style="display: none;">
                <canvas id="elbow-chart"></canvas>
            </div>
        </div>

        <div class="metrics" id="metrics-container">
            <div class="metric-card">
                <div class="metric-value" id="kmeans-inertia">-</div>
                <div class="metric-label">K-means Inertia</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="kmeans-silhouette">-</div>
                <div class="metric-label">K-means Silhouette Score</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="dbscan-clusters">-</div>
                <div class="metric-label">DBSCAN Clusters Found</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="dbscan-noise">-</div>
                <div class="metric-label">DBSCAN Noise Points</div>
            </div>
        </div>

        <div class="algorithm-comparison">
            <div class="algorithm-box kmeans-box">
                <h3>K-means Assumptions</h3>
                <ul>
                    <li>Spherical clusters</li>
                    <li>Similar sizes</li>
                    <li>Similar densities</li>
                    <li>Fixed number of clusters (K)</li>
                    <li>Minimizes within-cluster variance</li>
                </ul>
                <div class="warning-box" id="kmeans-warning" style="display: none;">
                    Warning: Current dataset violates K-means assumptions!
                </div>
            </div>
            <div class="algorithm-box dbscan-box">
                <h3>DBSCAN Characteristics</h3>
                <ul>
                    <li>Can find arbitrary shaped clusters</li>
                    <li>Handles different densities</li>
                    <li>Automatically determines number of clusters</li>
                    <li>Can identify noise/outliers</li>
                    <li>Requires density parameters (eps, minPts)</li>
                </ul>
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #ff6b6b;"></div>
                <span>Cluster 1</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #4ecdc4;"></div>
                <span>Cluster 2</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #45b7d1;"></div>
                <span>Cluster 3</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #fdcb6e;"></div>
                <span>Cluster 4+</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #cccccc;"></div>
                <span>Noise (DBSCAN)</span>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let kmeansChart, dbscanChart, elbowChart;
        let currentData = [];
        let groundTruthLabels = [];
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#fdcb6e', '#6c5ce7', '#a29bfe'];
        
        // Dataset descriptions
        const datasetDescriptions = {
            blobs: "Well-separated spherical clusters - K-means works perfectly here! This is the ideal case.",
            moons: "Two crescent moon shapes - K-means fails because it assumes spherical clusters.",
            circles: "Two concentric circles - K-means can't separate nested clusters.",
            aniso: "Clusters with different orientations and variances - K-means struggles with elongated clusters.",
            varied: "Clusters of very different sizes - K-means tends to split large clusters and merge small ones.",
            density: "Clusters with different densities - K-means may split dense clusters while merging sparse ones."
        };

        // Initialize charts
        function initCharts() {
            const kmeansCtx = document.getElementById('kmeans-chart').getContext('2d');
            const dbscanCtx = document.getElementById('dbscan-chart').getContext('2d');
            
            const chartConfig = {
                type: 'scatter',
                data: { datasets: [] },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: '', font: { size: 16 } }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            grid: { display: false }
                        },
                        y: {
                            type: 'linear',
                            grid: { display: false }
                        }
                    }
                }
            };
            
            kmeansChart = new Chart(kmeansCtx, {
                ...chartConfig,
                options: {
                    ...chartConfig.options,
                    plugins: {
                        ...chartConfig.options.plugins,
                        title: { display: true, text: 'K-means Clustering', font: { size: 16 } }
                    }
                }
            });
            
            dbscanChart = new Chart(dbscanCtx, {
                ...chartConfig,
                options: {
                    ...chartConfig.options,
                    plugins: {
                        ...chartConfig.options.plugins,
                        title: { display: true, text: 'DBSCAN Clustering', font: { size: 16 } }
                    }
                }
            });
        }

        // Generate different dataset types
        function generateDataset() {
            const datasetType = document.getElementById('dataset-select').value;
            const nPoints = parseInt(document.getElementById('n-points').value);
            
            currentData = [];
            groundTruthLabels = [];
            
            // Update description
            document.getElementById('dataset-description').textContent = datasetDescriptions[datasetType];
            
            // Show/hide warnings
            const warning = document.getElementById('kmeans-warning');
            warning.style.display = datasetType !== 'blobs' ? 'block' : 'none';
            
            switch(datasetType) {
                case 'blobs':
                    generateBlobs(nPoints);
                    break;
                case 'moons':
                    generateMoons(nPoints);
                    break;
                case 'circles':
                    generateCircles(nPoints);
                    break;
                case 'aniso':
                    generateAnisotropic(nPoints);
                    break;
                case 'varied':
                    generateVariedSizes(nPoints);
                    break;
                case 'density':
                    generateDifferentDensities(nPoints);
                    break;
            }
            
            // Auto-run clustering
            runClustering();
        }

        function generateBlobs(n) {
            const centers = [[2, 2], [-2, -2], [2, -2]];
            const pointsPerCluster = Math.floor(n / centers.length);
            
            centers.forEach((center, clusterIdx) => {
                for (let i = 0; i < pointsPerCluster; i++) {
                    const angle = Math.random() * 2 * Math.PI;
                    const r = Math.random() * 0.8;
                    currentData.push({
                        x: center[0] + r * Math.cos(angle),
                        y: center[1] + r * Math.sin(angle)
                    });
                    groundTruthLabels.push(clusterIdx);
                }
            });
        }

        function generateMoons(n) {
            const pointsPerMoon = Math.floor(n / 2);
            
            // First moon
            for (let i = 0; i < pointsPerMoon; i++) {
                const angle = Math.random() * Math.PI;
                const r = 1 + (Math.random() - 0.5) * 0.2;
                currentData.push({
                    x: r * Math.cos(angle),
                    y: r * Math.sin(angle)
                });
                groundTruthLabels.push(0);
            }
            
            // Second moon (flipped and shifted)
            for (let i = 0; i < pointsPerMoon; i++) {
                const angle = Math.random() * Math.PI;
                const r = 1 + (Math.random() - 0.5) * 0.2;
                currentData.push({
                    x: 1 - r * Math.cos(angle),
                    y: -0.5 - r * Math.sin(angle)
                });
                groundTruthLabels.push(1);
            }
        }

        function generateCircles(n) {
            const pointsPerCircle = Math.floor(n / 2);
            
            // Inner circle
            for (let i = 0; i < pointsPerCircle; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = 1 + (Math.random() - 0.5) * 0.2;
                currentData.push({
                    x: r * Math.cos(angle),
                    y: r * Math.sin(angle)
                });
                groundTruthLabels.push(0);
            }
            
            // Outer circle
            for (let i = 0; i < pointsPerCircle; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = 3 + (Math.random() - 0.5) * 0.3;
                currentData.push({
                    x: r * Math.cos(angle),
                    y: r * Math.sin(angle)
                });
                groundTruthLabels.push(1);
            }
        }

        function generateAnisotropic(n) {
            const pointsPerCluster = Math.floor(n / 3);
            
            // Horizontal ellipse
            for (let i = 0; i < pointsPerCluster; i++) {
                currentData.push({
                    x: (Math.random() - 0.5) * 4,
                    y: (Math.random() - 0.5) * 0.5 + 2
                });
                groundTruthLabels.push(0);
            }
            
            // Vertical ellipse
            for (let i = 0; i < pointsPerCluster; i++) {
                currentData.push({
                    x: (Math.random() - 0.5) * 0.5 - 2,
                    y: (Math.random() - 0.5) * 4
                });
                groundTruthLabels.push(1);
            }
            
            // Diagonal ellipse
            for (let i = 0; i < pointsPerCluster; i++) {
                const t = Math.random();
                const x = t * 3 - 1.5;
                const y = t * 3 - 1.5;
                currentData.push({
                    x: x + (Math.random() - 0.5) * 0.3,
                    y: y + (Math.random() - 0.5) * 0.3 - 2
                });
                groundTruthLabels.push(2);
            }
        }

        function generateVariedSizes(n) {
            // Large cluster (60% of points)
            const largeClusterSize = Math.floor(n * 0.6);
            for (let i = 0; i < largeClusterSize; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * 1.5;
                currentData.push({
                    x: r * Math.cos(angle),
                    y: r * Math.sin(angle)
                });
                groundTruthLabels.push(0);
            }
            
            // Medium cluster (30% of points)
            const mediumClusterSize = Math.floor(n * 0.3);
            for (let i = 0; i < mediumClusterSize; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * 0.5;
                currentData.push({
                    x: 3 + r * Math.cos(angle),
                    y: r * Math.sin(angle)
                });
                groundTruthLabels.push(1);
            }
            
            // Small cluster (10% of points)
            const smallClusterSize = n - largeClusterSize - mediumClusterSize;
            for (let i = 0; i < smallClusterSize; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * 0.2;
                currentData.push({
                    x: -2 + r * Math.cos(angle),
                    y: 2 + r * Math.sin(angle)
                });
                groundTruthLabels.push(2);
            }
        }

        function generateDifferentDensities(n) {
            // Dense cluster (40% of points in small area)
            const denseSize = Math.floor(n * 0.4);
            for (let i = 0; i < denseSize; i++) {
                currentData.push({
                    x: (Math.random() - 0.5) * 0.8 - 2,
                    y: (Math.random() - 0.5) * 0.8
                });
                groundTruthLabels.push(0);
            }
            
            // Sparse cluster (40% of points in large area)
            const sparseSize = Math.floor(n * 0.4);
            for (let i = 0; i < sparseSize; i++) {
                currentData.push({
                    x: (Math.random() - 0.5) * 4 + 2,
                    y: (Math.random() - 0.5) * 4
                });
                groundTruthLabels.push(1);
            }
            
            // Medium density cluster
            const mediumSize = n - denseSize - sparseSize;
            for (let i = 0; i < mediumSize; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * 0.8;
                currentData.push({
                    x: r * Math.cos(angle),
                    y: r * Math.sin(angle) + 3
                });
                groundTruthLabels.push(2);
            }
        }

        // K-means implementation
        function kmeans(data, k, initMethod = 'kmeans++') {
            let centroids = initializeCentroids(data, k, initMethod);
            let labels = new Array(data.length).fill(0);
            let oldLabels;
            let iterations = 0;
            const maxIterations = 100;
            
            do {
                oldLabels = [...labels];
                
                // Assign points to nearest centroid
                for (let i = 0; i < data.length; i++) {
                    let minDist = Infinity;
                    for (let j = 0; j < k; j++) {
                        const dist = euclideanDistance(data[i], centroids[j]);
                        if (dist < minDist) {
                            minDist = dist;
                            labels[i] = j;
                        }
                    }
                }
                
                // Update centroids
                const newCentroids = [];
                for (let j = 0; j < k; j++) {
                    const clusterPoints = data.filter((_, i) => labels[i] === j);
                    if (clusterPoints.length > 0) {
                        const sumX = clusterPoints.reduce((sum, p) => sum + p.x, 0);
                        const sumY = clusterPoints.reduce((sum, p) => sum + p.y, 0);
                        newCentroids.push({
                            x: sumX / clusterPoints.length,
                            y: sumY / clusterPoints.length
                        });
                    } else {
                        // Empty cluster, reinitialize randomly
                        newCentroids.push(data[Math.floor(Math.random() * data.length)]);
                    }
                }
                centroids = newCentroids;
                
                iterations++;
            } while (!arraysEqual(labels, oldLabels) && iterations < maxIterations);
            
            // Calculate inertia (sum of squared distances to centroids)
            let inertia = 0;
            for (let i = 0; i < data.length; i++) {
                inertia += Math.pow(euclideanDistance(data[i], centroids[labels[i]]), 2);
            }
            
            return { labels, centroids, inertia, iterations };
        }

        function initializeCentroids(data, k, method) {
            if (method === 'random') {
                // Random initialization
                const shuffled = [...data].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, k);
            } else {
                // K-means++ initialization
                const centroids = [];
                
                // Choose first centroid randomly
                centroids.push(data[Math.floor(Math.random() * data.length)]);
                
                // Choose remaining centroids
                for (let i = 1; i < k; i++) {
                    const distances = data.map(point => {
                        const minDist = Math.min(...centroids.map(c => euclideanDistance(point, c)));
                        return minDist * minDist;
                    });
                    
                    // Choose point with probability proportional to squared distance
                    const totalDist = distances.reduce((sum, d) => sum + d, 0);
                    let random = Math.random() * totalDist;
                    
                    for (let j = 0; j < data.length; j++) {
                        random -= distances[j];
                        if (random <= 0) {
                            centroids.push(data[j]);
                            break;
                        }
                    }
                }
                
                return centroids;
            }
        }

        // DBSCAN implementation
        function dbscan(data, eps, minPts) {
            const labels = new Array(data.length).fill(-1); // -1 = unvisited
            let clusterLabel = 0;
            
            for (let i = 0; i < data.length; i++) {
                if (labels[i] !== -1) continue; // Already visited
                
                const neighbors = getNeighbors(data, i, eps);
                
                if (neighbors.length < minPts) {
                    labels[i] = -2; // Mark as noise
                } else {
                    labels[i] = clusterLabel;
                    expandCluster(data, labels, i, neighbors, clusterLabel, eps, minPts);
                    clusterLabel++;
                }
            }
            
            return labels;
        }

        function expandCluster(data, labels, pointIdx, neighbors, clusterLabel, eps, minPts) {
            for (let i = 0; i < neighbors.length; i++) {
                const neighborIdx = neighbors[i];
                
                if (labels[neighborIdx] === -2) {
                    // Change noise to border point
                    labels[neighborIdx] = clusterLabel;
                }
                
                if (labels[neighborIdx] !== -1) continue; // Already processed
                
                labels[neighborIdx] = clusterLabel;
                
                const neighborNeighbors = getNeighbors(data, neighborIdx, eps);
                if (neighborNeighbors.length >= minPts) {
                    // Add new neighbors
                    for (const nn of neighborNeighbors) {
                        if (!neighbors.includes(nn)) {
                            neighbors.push(nn);
                        }
                    }
                }
            }
        }

        function getNeighbors(data, pointIdx, eps) {
            const neighbors = [];
            for (let i = 0; i < data.length; i++) {
                if (i !== pointIdx && euclideanDistance(data[pointIdx], data[i]) <= eps) {
                    neighbors.push(i);
                }
            }
            return neighbors;
        }

        // Utility functions
        function euclideanDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function arraysEqual(a1, a2) {
            return a1.length === a2.length && a1.every((val, idx) => val === a2[idx]);
        }

        // Calculate silhouette score
        function calculateSilhouette(data, labels) {
            const k = Math.max(...labels) + 1;
            if (k < 2) return 0;
            
            let totalSilhouette = 0;
            let validPoints = 0;
            
            for (let i = 0; i < data.length; i++) {
                if (labels[i] === -2) continue; // Skip noise points
                
                // Calculate a(i) - average distance to points in same cluster
                const sameCluster = data.filter((_, j) => labels[j] === labels[i] && i !== j);
                if (sameCluster.length === 0) continue;
                
                const a = sameCluster.reduce((sum, p) => sum + euclideanDistance(data[i], p), 0) / sameCluster.length;
                
                // Calculate b(i) - minimum average distance to points in other clusters
                let b = Infinity;
                for (let c = 0; c < k; c++) {
                    if (c === labels[i]) continue;
                    
                    const otherCluster = data.filter((_, j) => labels[j] === c);
                    if (otherCluster.length === 0) continue;
                    
                    const avgDist = otherCluster.reduce((sum, p) => sum + euclideanDistance(data[i], p), 0) / otherCluster.length;
                    b = Math.min(b, avgDist);
                }
                
                if (b !== Infinity) {
                    const s = (b - a) / Math.max(a, b);
                    totalSilhouette += s;
                    validPoints++;
                }
            }
            
            return validPoints > 0 ? totalSilhouette / validPoints : 0;
        }

        // Visualization functions
        function visualizeClustering(chart, data, labels, centroids = null, title = '') {
            const datasets = [];
            const k = Math.max(...labels.filter(l => l >= 0)) + 1;
            
            // Create datasets for each cluster
            for (let i = 0; i < k; i++) {
                const clusterData = data.filter((_, idx) => labels[idx] === i);
                datasets.push({
                    label: `Cluster ${i + 1}`,
                    data: clusterData,
                    backgroundColor: colors[i % colors.length],
                    borderColor: colors[i % colors.length],
                    pointRadius: 5,
                    pointHoverRadius: 7
                });
            }
            
            // Add noise points for DBSCAN
            const noiseData = data.filter((_, idx) => labels[idx] === -2);
            if (noiseData.length > 0) {
                datasets.push({
                    label: 'Noise',
                    data: noiseData,
                    backgroundColor: '#cccccc',
                    borderColor: '#999999',
                    pointRadius: 3,
                    pointHoverRadius: 5
                });
            }
            
            // Add centroids for K-means
            if (centroids) {
                datasets.push({
                    label: 'Centroids',
                    data: centroids,
                    backgroundColor: 'black',
                    borderColor: 'white',
                    borderWidth: 2,
                    pointRadius: 10,
                    pointHoverRadius: 12,
                    pointStyle: 'rectRot'
                });
            }
            
            chart.data.datasets = datasets;
            chart.options.plugins.title.text = title;
            chart.update();
        }

        // Main clustering function
        function runClustering() {
            if (currentData.length === 0) {
                generateDataset();
                return;
            }
            
            const k = parseInt(document.getElementById('n-clusters').value);
            const initMethod = document.getElementById('init-method').value;
            const eps = parseFloat(document.getElementById('dbscan-eps').value);
            const minPts = parseInt(document.getElementById('dbscan-minpts').value);
            
            // Run K-means
            const kmeansResult = kmeans(currentData, k, initMethod);
            visualizeClustering(kmeansChart, currentData, kmeansResult.labels, kmeansResult.centroids, 'K-means Clustering');
            
            // Run DBSCAN
            const dbscanLabels = dbscan(currentData, eps, minPts);
            visualizeClustering(dbscanChart, currentData, dbscanLabels, null, 'DBSCAN Clustering');
            
            // Update metrics
            document.getElementById('kmeans-inertia').textContent = kmeansResult.inertia.toFixed(2);
            document.getElementById('kmeans-silhouette').textContent = calculateSilhouette(currentData, kmeansResult.labels).toFixed(3);
            
            const dbscanClusters = Math.max(...dbscanLabels.filter(l => l >= 0)) + 1;
            const dbscanNoise = dbscanLabels.filter(l => l === -2).length;
            document.getElementById('dbscan-clusters').textContent = dbscanClusters || 0;
            document.getElementById('dbscan-noise').textContent = dbscanNoise;
        }

        // Show initialization sensitivity
        function runMultipleInits() {
            if (currentData.length === 0) {
                generateDataset();
                return;
            }
            
            const k = parseInt(document.getElementById('n-clusters').value);
            const results = [];
            
            // Run K-means multiple times with random initialization
            for (let run = 0; run < 10; run++) {
                const result = kmeans(currentData, k, 'random');
                results.push({
                    run: run + 1,
                    inertia: result.inertia,
                    iterations: result.iterations
                });
            }
            
            // Show results
            const minInertia = Math.min(...results.map(r => r.inertia));
            const maxInertia = Math.max(...results.map(r => r.inertia));
            const variance = maxInertia - minInertia;
            
            alert(`Initialization Sensitivity (10 runs with random init):\n\n` +
                  `Best Inertia: ${minInertia.toFixed(2)}\n` +
                  `Worst Inertia: ${maxInertia.toFixed(2)}\n` +
                  `Variance: ${variance.toFixed(2)}\n\n` +
                  `This shows how different initializations can lead to different results!\n` +
                  `K-means++ initialization typically reduces this variance.`);
        }

        // Elbow method
        function showElbowMethod() {
            if (currentData.length === 0) {
                generateDataset();
                return;
            }
            
            document.getElementById('elbow-container').style.display = 'block';
            
            const maxK = 10;
            const inertias = [];
            const silhouettes = [];
            
            for (let k = 1; k <= maxK; k++) {
                const result = kmeans(currentData, k, 'kmeans++');
                inertias.push(result.inertia);
                
                if (k > 1) {
                    silhouettes.push(calculateSilhouette(currentData, result.labels));
                } else {
                    silhouettes.push(0);
                }
            }
            
            // Create elbow chart
            const ctx = document.getElementById('elbow-chart').getContext('2d');
            
            if (elbowChart) {
                elbowChart.destroy();
            }
            
            elbowChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: maxK}, (_, i) => i + 1),
                    datasets: [
                        {
                            label: 'Inertia',
                            data: inertias,
                            borderColor: '#ff6b6b',
                            backgroundColor: 'rgba(255, 107, 107, 0.1)',
                            yAxisID: 'y-inertia',
                            tension: 0.1
                        },
                        {
                            label: 'Silhouette Score',
                            data: silhouettes,
                            borderColor: '#4ecdc4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            yAxisID: 'y-silhouette',
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Elbow Method: Finding Optimal K',
                            font: { size: 16 }
                        },
                        legend: {
                            display: true
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Number of Clusters (K)'
                            }
                        },
                        'y-inertia': {
                            type: 'linear',
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Inertia'
                            }
                        },
                        'y-silhouette': {
                            type: 'linear',
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Silhouette Score'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }

        // Update functions
        function updateClusterCount() {
            document.getElementById('n-clusters-value').textContent = document.getElementById('n-clusters').value;
            runClustering();
        }

        function updateEps() {
            document.getElementById('dbscan-eps-value').textContent = document.getElementById('dbscan-eps').value;
            runClustering();
        }

        function updateMinPts() {
            document.getElementById('dbscan-minpts-value').textContent = document.getElementById('dbscan-minpts').value;
            runClustering();
        }

        function updatePointCount() {
            document.getElementById('n-points-value').textContent = document.getElementById('n-points').value;
            generateDataset();
        }

        // Initialize on load
        window.onload = function() {
            initCharts();
            generateDataset();
        };
    </script>
</body>
</html>